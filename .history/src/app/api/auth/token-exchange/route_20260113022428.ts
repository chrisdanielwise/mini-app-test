import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/db";
import { createJWT } from "@/lib/auth/telegram";
import { JWT_CONFIG, getSecurityContext } from "@/lib/auth/config";
import { cookies } from "next/headers";

/**
 * üõ∞Ô∏è TOKEN EXCHANGE HANDSHAKE (Institutional v12.9.0)
 * Logic: One-Time Token (OTT) Conversion to Stateless Hybrid Session.
 * Architecture: Environment-Aware Cookie Deployment via getSecurityContext.
 */
export async function POST(request: NextRequest) {
  try {
    const { token } = await request.json();

    if (!token) {
      return NextResponse.json({ error: "link_invalid" }, { status: 400 });
    }

    // üïµÔ∏è 1. IDENTITY RETRIEVAL (Full Relationship Ingress)
    // Locates the user via the OTT generated by the Telegram Webhook.
    const user = await prisma.user.findFirst({
      where: {
        lastLoginToken: token,
        tokenExpires: { gt: new Date() },
      },
      include: {
        merchantProfile: { select: { id: true } }, // Resolves Owner Context
        teamMemberships: { take: 1, select: { merchantId: true } } // Resolves Agent Context
      },
    });

    if (!user) {
      return NextResponse.json({ error: "link_invalid" }, { status: 401 });
    }

    // üõ°Ô∏è 2. ROLE & CLEARANCE EVALUATION
    const normalizedRole = user.role.toLowerCase();
    
    // Check against centralized staff roles in JWT_CONFIG
    const isPlatformStaff = JWT_CONFIG.staffRoles.includes(normalizedRole);

    // üöÄ 3. MERCHANT ID RESOLUTION (Staff-Aware Logic)
    const resolvedMerchantId = 
      user.merchantProfile?.id || 
      user.teamMemberships[0]?.merchantId || 
      null;

    // üîê 4. SESSION GENERATION
    // Includes BigInt safety for Telegram IDs and isStaff flag for Proxy performance.
    const jwt = await createJWT({
      userId: user.id,
      telegramId: user.telegramId.toString(),
      role: normalizedRole,
      merchantId: resolvedMerchantId,
      isStaff: isPlatformStaff 
    });

    // 5. ATOMIC CONSUMPTION
    // Prevents replay attacks by wiping the OTT immediately upon successful exchange.
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLoginToken: null, tokenExpires: null }
    });

    // üèÅ 6. SECURE COOKIE DEPLOYMENT
    const cookieStore = await cookies();
    
    // Resolve security flags (Secure, SameSite, Partitioned) using central utility
    const host = request.headers.get("host");
    const protocol = request.headers.get("x-forwarded-proto");
    const security = getSecurityContext(host, protocol);

    cookieStore.set(JWT_CONFIG.cookieName, jwt, {
      ...JWT_CONFIG.cookieOptions,
      secure: security.secure,
      sameSite: security.sameSite,
      // @ts-ignore - Required for 2026 CHIPS / Iframe session persistence in Safari
      partitioned: security.partitioned, 
    });

    // üöÄ 7. HYBRID PAYLOAD
    // We return the token in the JSON body so the useAuth hook can also 
    // anchor it in Telegram's native SecureStorage (the Safari loop killer).
    console.log(`‚úÖ [Auth_Sync] Session Anchored: ${user.id} | Mode: ${security.partitioned ? 'Partitioned' : 'Lax'}`);
    
    return NextResponse.json({ 
      success: true,
      data: {
        token: jwt,
        user: {
          id: user.id,
          telegramId: user.telegramId.toString(),
          role: normalizedRole,
          merchantId: resolvedMerchantId,
        }
      }
    });

  } catch (error: any) {
    console.error("üî• [Auth_Handshake_Critical]:", error.message);
    return NextResponse.json({ error: "identity_denied" }, { status: 500 });
  }
}